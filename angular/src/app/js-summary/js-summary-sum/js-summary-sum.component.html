<app-js-template-sum title="window.performance.timing">
    <ng-template appJsTemplateSum>
        <h3>window.performance.timing(html5的属性)</h3>
        <ul>
            <li>
                <h6>navigationStart</h6>
                <p>当前浏览器窗口的前一个网页关闭，发生unload事件时的Unix毫秒时间戳。如果没有前一个网页，则等于fetchStart属性</p>
            </li>
            <li>
                <h6>unloadEventStart</h6>
                <p>如果前一个网页与当前网页属于同一个域名，则返回前一个网页的unload事件发生时的Unix毫秒时间戳。如果没有前一个网页，或者之前的网页跳转不是在同一个域名内，则返回值为0</p>
            </li>
            <li>
                <h6>unloadEventEnd</h6>
                <p>如果前一个网页与当前网页属于同一个域名，则返回前一个网页unload事件的回调函数结束时的Unix毫秒时间戳。如果没有前一个网页，或者之前的网页跳转不是在同一个域名内，则返回值为0</p>
            </li>
            <li>
                <h6>redirectStart</h6>
                <p>返回第一个HTTP跳转开始时的Unix毫秒时间戳。如果没有跳转，或者不是同一个域名内部的跳转，则返回值为0</p>
            </li>
            <li>
                <h6>redirectEnd</h6>
                <p>返回最后一个HTTP跳转结束时（即跳转回应的最后一个字节接受完成时）的Unix毫秒时间戳。如果没有跳转，或者不是同一个域名内部的跳转，则返回值为0</p>
            </li>
            <li>
                <h6>fetchStart</h6>
                <p>返回浏览器准备使用HTTP请求读取文档时的Unix毫秒时间戳。该事件在网页查询本地缓存之前发生</p>
            </li>
            <li>
                <h6>domainLookupStart</h6>
                <p>返回域名查询开始时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值</p>
            </li>
            <li>
                <h6>domainLookupEnd</h6>
                <p>返回域名查询结束时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值</p>
            </li>
            <li>
                <h6>connectStart</h6>
                <p>返回HTTP请求开始向服务器发送时的Unix毫秒时间戳。如果使用持久连接（persistent connection），则返回值等同于fetchStart属性的值</p>
            </li>
            <li>
                <h6>connectEnd</h6>
                <p>返回浏览器与服务器之间的连接建立时的Unix毫秒时间戳。如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束</p>
            </li>
            <li>
                <h6>secureConnectionStart</h6>
                <p>返回浏览器与服务器开始安全链接的握手时的Unix毫秒时间戳。如果当前网页不要求安全连接，则返回0</p>
            </li>
            <li>
                <h6>requestStart</h6>
                <p>返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的Unix毫秒时间戳</p>
            </li>
            <li>
                <h6>responseStart</h6>
                <p>返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的Unix毫秒时间戳</p>
            </li>
            <li>
                <h6>responseEnd</h6>
                <p>返回浏览器从服务器收到（或从本地缓存读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的Unix毫秒时间戳</p>
            </li>
            <li>
                <h6>domLoading</h6>
                <p>返回当前网页DOM结构开始解析时（即Document.readyState属性变为“loading”、相应的readystatechange事件触发时）的Unix毫秒时间戳</p>
            </li>
            <li>
                <h6>domInteractive</h6>
                <p>返回当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为“interactive”、相应的readystatechange事件触发时）的Unix毫秒时间戳</p>
            </li>
            <li>
                <h6>domContentLoadedEventStart</h6>
                <p>返回当前网页DOMContentLoaded事件发生时（即DOM结构解析完毕、所有脚本开始运行时）的Unix毫秒时间戳</p>
            </li>
            <li>
                <h6>domContentLoadedEventEnd</h6>
                <p>返回当前网页所有需要执行的脚本执行完成时的Unix毫秒时间戳</p>
            </li>
            <li>
                <h6>domComplete</h6>
                <p>返回当前网页DOM结构生成时（即Document.readyState属性变为“complete”，以及相应的readystatechange事件发生时）的Unix毫秒时间戳</p>
            </li>
            <li>
                <h6>loadEventStart</h6>
                <p>返回当前网页load事件的回调函数开始时的Unix毫秒时间戳。如果该事件还没有发生，返回0</p>
            </li>
            <li>
                <h6>loadEventEnd</h6>
                <p>返回当前网页load事件的回调函数运行结束时的Unix毫秒时间戳。如果该事件还没有发生，返回0</p>
            </li>
        </ul>
    </ng-template>
</app-js-template-sum>
<app-js-template-sum title="html页面的渲染过程">
    <ng-template appJsTemplateSum>
        <h3>页面的渲染</h3>
        <ul>
            <li>单线程事件轮询</li>
            <li>定义明确、连续、操作有序（HTML5）</li>
            <li>分词和构建DOM树</li>
            <li>请求资源并预加载</li>
            <li>构建渲染树并绘制页面</li>
        </ul>
        <h6>DOM树的构建会被阻塞</h6>
        <ul>
            <li>HTML的响应流被阻塞在了网络中</li>
            <li>有未加载完的脚本</li>
            <li>遇到了script节点，但是此时还有未加载完的样式文件</li>
        </ul>
        <h6>不会阻塞页面渲染</h6>
        <ul>
            <li>定义的defer属性和async属性</li>
            <li>没有匹配的媒体类型的样式文件</li>
            <li>没有通过解析器插入script节点或样式节点</li>
        </ul>
    </ng-template>
</app-js-template-sum>
<app-js-template-sum title="渲染树构建之渲染树和DOM树的关系">
    <ng-template appJsTemplateSum>
        <h3>渲染树构建之渲染树和DOM树的关系</h3>
        <ul>
            <li>在DOM树构建的同时，浏览器会构建渲染树（render tree）</li>
            <li>渲染树的节点（渲染器），在Gecko中称为frame，而在webkit中称为renderer</li>
            <li>渲染器是在文档解析和创建DOM节点后创建的，会计算DOM节点的样式信息</li>
            <li> 在webkit中，renderer是由DOM节点调用attach()方法创建的</li>
            <li>
                <p>attach()方法计算了DOM节点的样式信息</p>
                <ul>
                    <li>attach()是自上而下的递归操作。也就是说，父节点总是比子节点先创建自己的renderer</li>
                    <li>销毁的时候，则是自下而上的递归操作，也就是说，子节点总是比父节点先销毁</li>
                </ul>
            </li>
        </ul>
    </ng-template>
</app-js-template-sum>
<app-js-template-sum title="浏览器的运行机制">
    <ng-template appJsTemplateSum>
        <h3>渲染进程包括哪些线程</h3>
        <ul>
            <li>
                <h6>GUI渲染线程</h6>
                <ul>
                    <li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等</li>
                    <li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li>
                    <li>注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行</li>
                </ul>
            </li>
            <li>
                <h6>JS引擎线程(单线程)</h6>
                <ul>
                    <li>也称为JS内核，负责处理Javascript脚本程序。（例如常常听到的谷歌浏览器的V8引擎，新版火狐的JaegerMonkey引擎等）</li>
                    <li>JS引擎线程负责解析Javascript脚本，运行代码</li>
                    <li>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</li>
                    <li>同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞</li>
                </ul>
            </li>
            <li>
                <h6>事件触发线程</h6>
                <ul>
                    <li>归属于渲染进程而不是JS引擎，用来控制事件轮询（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</li>
                    <li>当JS引擎执行代码块如鼠标点击、AJAX异步请求等，会将对应任务添加到事件触发线程中</li>
                    <li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理任务队列的队尾，等待JS引擎的处理</li>
                    <li>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</li>
                </ul>
            </li>
            <li>
                <h6>定时触发器线程</h6>
                <ul>
                    <li>定时器setInterval与setTimeout所在线程</li>
                    <li>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果任务队列处于阻塞线程状态就会影响记计时的准确）</li>
                    <li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</li>
                    <li>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms</li>
                </ul>
            </li>
            <li>
                <h6>异步http请求线程</h6>
                <ul>
                    <li>用于处理请求XMLHttpRequest，在连接后是通过浏览器新开一个线程请求。如ajax，是浏览器新开一个http线程</li>
                    <li>将检测到状态变更（如ajax返回结果）时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入js引擎线程的事件队列中。再由JavaScript引擎执行</li>
                </ul>
            </li>
            <li>
                <h6>渲染进程中的线程之间的关系</h6>
                <ul>
                    <li>
                        <p>GUI渲染线程与JS引擎线程互斥</p>
                        <ul>
                            <li>由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和GUI线程同时运行）</li>
                            <li>那么渲染线程前后获得的元素数据就可能不一致了</li>
                            <li>浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起</li>
                            <li>GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行</li>
                        </ul>
                    </li>
                    <li>
                        <p>JS阻塞页面加载</p>
                        <ul>
                            <li>JS如果执行时间过长就会阻塞页面</li>
                            <li>所以JS引擎很可能很久很久后才能空闲，所以导致页面渲染加载阻塞</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <h6>js引擎是单线程的</h6>
                <ul>
                    <li>作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM</li>
                    <li>JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变</li>
                    <li>
                        <p>HTML5提出Web Worker标准</p>
                        <ul>
                            <li>允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <h6>js事件轮询</h6>
                <ul>
                    <li>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着</li>
                    <li>如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行</li>
                    <li>
                        <p>io设备的限制</p>
                        <ul>
                            <li>
                                <p>一种是同步任务（synchronous）</p>
                                <ul>
                                    <li>在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务</li>
                                </ul>
                            </li>
                            <li>
                                <p>一种是异步任务（asynchronous）</p>
                                <ul>
                                    <li>异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <p>js的事件轮询机制</p>
                        <ul>
                            <li>所有同步任务都在主线程（即js引擎线程）上执行，形成一个执行栈</li>
                            <li>
                                <p>异步任务均由事件触发线程控制，其有一个任务队列</p>
                                <ul>
                                    <li>只要异步任务有了运行结果，就在"任务队列"之中放置回调事件</li>
                                    <li>异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数</li>
                                    <li>所以所谓"回调函数"（callback），就是那些会被主线程挂起来的代码</li>
                                </ul>
                            </li>
                            <li>一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，按顺序结束等待状态，进入执行栈，开始执行</li>
                            <li>主线程不断重复上面的第三步</li>
                            <li>
                                <p>同步异步执行顺序</p>
                                <ul>
                                    <li>只要主线程空了，就会去读取"任务队列"，这个过程会不断重复</li>
                                    <li>这就是JavaScript的运行机制。又称为Event Loop（事件循环或者轮询）</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <h6>定时器触发线程</h6>
                <p>JS引擎线程和事件触发线程</p>
                <ul>
                    <li>js来控制主线程，事件触发来控制任务队列就如主线程</li>
                    <li>JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时</li>
                    <li>当使用setTimeout或setInterval时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件触发线程的任务队列中</li>
                </ul>
            </li>
            <li>
                <h6>注意</h6>
                <ul>
                    <li>虽然代码的本意是0毫秒后就推入事件队列，但是html5标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms</li>
                    <li>算不等待4ms，就算假设0毫秒就推入事件队列，也会先执行begin（因为只有主线程可执行栈内空了后才会主动读取事件队列）</li>
                    <li>
                        <p>误差</p>
                        <ul>
                            <li>回调函数一定会在setTimeout()指定的时间执行。同理setInterval则是每次都精确的隔一段时间推入一个事件</li>
                            <li>事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </ng-template>
</app-js-template-sum>
<app-js-template-sum title="JS事件循环机制（event loop）之宏任务、微任务">
    <ng-template appJsTemplateSum>
        <h3>JS事件循环机制（event loop）之宏任务、微任务</h3>
        <ul>
            <li>
                <h6>demo</h6>
                <pre>
console.log('script start');

setTimeout(function() ｛
    console.log('setTimeout');
｝, 0);

Promise.resolve().then(function() ｛
        console.log('promise1');
    ｝).then(function() ｛
        console.log('promise2');
｝);

console.log('script end');
                </pre>
                <p>正确答案是:script start, script end, promise1, promise2, setTimeout</p>
            </li>
            <li>
                <h6>线程中的event loop(事件循环)</h6>
                <ul>
                    <li>每个线程都会有它自己的event loop(事件循环)，所以都能独立运行</li>
                    <li>所有同源窗口会共享一个event loop以同步通信</li>
                    <li>event loop会一直运行，来执行进入队列的宏任务</li>
                    <li>一个event loop有多种的宏任务源（译者注：event等等），这些宏任务源保证了在本任务源内的顺序</li>
                    <li>但是浏览器每次都会选择一个源中的一个宏任务去执行(保证了浏览器给与一些宏任务（如用户输入）以更高的优先级)</li>
                </ul>
            </li>
            <li>
                <h6>宏任务（task）</h6>
                <ul>
                    <li>浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染 （task->渲染->task->...）</li>
                    <li>鼠标点击会触发一个事件回调，需要执行一个宏任务，然后解析HTMl</li>
                    <li>
                        <p>setTimeout的作用是等待给定的时间后为它的回调产生一个新的宏任务</p>
                        <span>打印‘script end’是第一个宏任务里面的事情，而‘setTimeout’是另一个独立的任务里面打印的</span>
                    </li>
                </ul>
            </li>
            <li>
                <h6>微任务（Microtasks ）</h6>
                <ul>
                    <li>
                        <p>微任务的定义</p>
                        <span>微任务通常来说就是需要在当前 task 执行结束后立即执行的任务，比如对一系列动作做出反馈，或或者是需要异步的执行任务而又不需要分配一个新的
                            task，这样便可以减小一点性能的开销</span>
                    </li>
                    <li>
                        <p>微任务执行顺序</p>
                        <ul>
                            <li>只要执行栈中没有其他的js代码正在执行且每个宏任务执行完，微任务队列会立即执行</li>
                            <li>如果在微任务执行期间微任务队列加入了新的微任务，会将新的微任务加入队列尾部，之后也会被执行</li>
                        </ul>
                    </li>
                    <li>
                        <p>微任务定义</p>
                        <span>微任务包括了mutation observe的回调还有接下来的例子promise的回调</span>
                    </li>
                    <li>
                        <p>微任务的栗子</p>
                        <ul>
                            <li>一旦一个pormise有了结果，或者早已有了结果（有了结果是指这个promise到了fulfilled或rejected状态），他就会为它的回调产生一个微任务，这就保证了回调异步的执行即使这个promise早已有了结果</li>
                            <li>所以对一个已经有了结果的promise调用.then(yey, nay)会立即产生一个微任务</li>
                            <li>这就是为什么‘promise1’,'promise2'会打印在‘script end’之后，因为所有微任务执行的时候，当前执行栈的代码必须已经执行完毕</li>
                            <li>‘promise1’,'promise2'会打印在‘setTimeout’之前是因为所有微任务总会在下一个宏任务之前全部执行完毕</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <h6>浏览器对于demo代码执行顺序不一致解释</h6>
                <ul>
                    <li>
                        <p>根据观测的结论</p>
                        <ul>
                            <li>这些浏览器会把promise的回调视作一个新的宏任务而不是微任务</li>
                            <li>因为promises 来自于ECMAScript 的标准而不是HTML标准</li>
                        </ul>
                    </li>
                    <li>
                        <p>渲染模式的性能问题</p>
                        <ul>
                            <li>如果说把 promise 当做一个新的 task 来执行的话，这将会造成一些性能上的问题，因为 promise 的回调函数可能会被延迟执行，因为在每一个 task
                                执行结束后浏览器可能会进行一些渲染工作</li>
                            <li>由于作为一个 task 将会和其他任务来源（task source）相互影响，这也会造成一些不确定性，同时这也将打破一些与其他 API 的交互，这样一来便会造成一系列的问题</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <h6>分辨宏任务和微任务</h6>
                <pre>
html:
div class="outer">/div>
    div class="inner">/div>
/div>

js:
// Let's get hold of those elements
var outer = document.querySelector('.outer');
var inner = document.querySelector('.inner');

// Let's listen for attribute changes on the
// outer element
//监听element属性变化
new MutationObserver(function() ｛
  console.log('mutate');
}).observe(outer, ｛
  attributes: true
});

// Here's a click listener…
function onClick() ｛
  console.log('click');

  setTimeout(function() ｛
    console.log('timeout');
  }, 0);

  Promise.resolve().then(function() ｛
    console.log('promise');
  });

  outer.setAttribute('data-random', Math.random());
}

// …which we'll attach to both elements
inner.addEventListener('click', onClick);
outer.addEventListener('click', onClick);

// 结果
click
promise
mutate
click
promise
mutate
timeout
timeout
                </pre>
                <p>流程描述</p>
                <ul>
                    <li>分发click event是一个宏任务，Mutation observer和promise都会进入微任务队列，setTimeout回调是一个宏任务</li>
                    <li>如果js执行栈空了,立即执行microtask checkpoint 会检查整个微任务队列，除非正在执行这个检查动作</li>
                </ul>
                <pre>
// 直接执行
inner.click();

// 结果
click
click
promise
mutate
promise
timeout
timeout
                </pre>
                <p>我们不一样</p>
                <ul>
                    <li>之前的例子，微任务会在监听器回调之间执行</li>
                    <li>click()会导致事件同步分发，所以在监听器回调之间Js执行栈不为空</li>
                    <li>上述的这个规则保证了微任务不会打断正在执行的js.这意味着我们不能在监听器回调之间执行微任务，微任务会在监听器之后执行</li>
                </ul>
            </li>
        </ul>
        <h6>总结</h6>
        <ul>
            <li>宏任务按顺序执行，且浏览器在每个宏任务之间渲染页面</li>
            <li>
                <p>所有微任务也按顺序执行，且在以下场景会立即执行所有微任务</p>
                <ul>
                    <li>每个回调之后且js执行栈中为空</li>
                    <li>每个宏任务结束后</li>
                </ul>
            </li>
        </ul>
        <h6>事件循环第三方讲解</h6>
        <p>上：https://zhuanlan.zhihu.com/p/26229293</p>
        <p>下：https://zhuanlan.zhihu.com/p/26238030</p>
    </ng-template>
</app-js-template-sum>
<app-js-template-sum title="js构造抽象语法书（AST）">
    <ng-template appJsTemplateSum>
        <h6>编程语言原理</h6>
        <ul>
            <li>需要一些软件来处理源代码以便让计算机能够理解</li>
            <ul>
                <li>解释型语言(JavaScript、Python、Ruby)——解释器</li>
                <li>编译型语言(c#、Java、Rust)——编译器</li>
            </ul>
            <li>将源代码作为纯文本解析为 抽象语法树(abstract syntax tree, AST) 的数据结构</li>
            <li>
                <p>AST作用</p>
                <ul>
                    <li>以结构化的方式显示源代码</li>
                    <li>在语义分析中，编译器验证程序和语言元素的语法使用是否正确</li>
                    <li>AST 来生成实际的字节码或者机器码</li>
                </ul>
                <p>AST详解</p>
                <ul>
                    <li>抽象语法树（abstract syntax tree 或者缩写为 AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码</li>
                    <li>和抽象语法树相对的是具体语法树（concrete syntaxtree），通常称作分析树（parse tree）</li>
                    <li>在源代码的翻译和编译过程中，语法分析器创建出分析树</li>
                </ul>
            </li>
            <li>
                <p>AST程序</p>
                <ul>
                    <li>AST 不仅仅是用于语言解释器和编译器，在计算机世界中，它们还有多种应用。使用它们最常见的方法之一是进行静态代码分析</li>
                    <li>Esprima 和 Acorn 帮助解析器生成输出</li>
                    <li>
                        <p>例如：</p>
                        <ul>
                            <li>实现一个将 Python 代码转换为J avaScript 的转换器</li>
                            <li>使用Python 转换器生成 AST，然后使用 AST 生成JavaScript代码</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
        <h6>JavaScript 解析</h6>
        <pre>
function foo(x) ｛
    if (x > 10) ｛
        var a = 2;
        return a * x;
    }

    return x + 10;
}
        </pre>
        <p>解析器会产生如下的 AST</p>
        <img src="https://image.fundebug.com/2019-01-21-01.png">
        <a href="https://astexplorer.net/">在线javascript AST解析</a>
        <h6>js文件-解析</h6>
        <ul>
            <li>浏览器解析 JavaScript 大约需占总执行时间的 15% 到 20%</li>
            <li>一个典型的单页程序加载 0.4 mb 左右的 JavaScript，浏览器需要大约 370ms 来解析</li>
            <li>在手机上花在解析上的时间通常是桌面浏览器的 2 到 5 倍</li>
        </ul>
        <h6>js文件-渲染优化</h6>
        <ul>
            <li>
                <p>启发法</p>
                <ul>
                    <li>现代JavaScript 解析器使用 启发法(heuristics) 来决定是否立即运行指定的代码片段或者推迟在未来的某个时候运行。基于这些启发法，解析器将进行即时或懒解析</li>
                    <li>
                        <p>启发法</p>
                        <ul>
                            <li>启发法是针对模型求解方法而言的，是一种逐次逼近最优解的方法</li>
                            <li>启发法的特点是模型简单，需要进行方案组合的个数少，因此便于找出最终答案。此方法虽不能保证得到最优解，但只要处理得当，可获得决策者满意的近似最优解</li>
                            <li>一般步骤包括:定义一个计算总费用的方法;报定判别准则;规定方案改选的途径;建立相应的模型;送代求解</li>
                        </ul>
                    </li>
                    <li>立即解析会运行需要立即编译的函数。它主要做三件事:构建 AST，构建作用域层级和查找所有语法错误</li>
                    <li>懒解析只运行未编译的函数。它不构建AST，也不查找所有语法错误，它只构建作用域层级，与立即解析相比节省了大约一半的时间</li>
                </ul>
            </li>
            <li>
                <p>立即解析</p>
                <pre>
var myModule = (function() ｛
    // 整个模块的逻辑
    // 返回模块对象
})();
                </pre>
                <ul>
                    <li>大多数现代 JavaScript 解析器都能识别这种模式，此模式表示代码需要立即解析</li>
                    <li>需要运行一次懒解析之后进行另一个立即解析，这和立即解析相比，运行速度会慢 50%</li>
                    <li>大多数解析器都能识别一种模式:使用括号封装函数</li>
                    <li>如果解析器看到一个左括号，紧接着是一个函数声明，它将立即解析这个函数。可以通过显式地声明立即执行的函数来帮助解析器加快解析速度</li>
                </ul>
                <p>示例</p>
                <pre>
function foo(x) ｛
    return x * 10;
}                                
                </pre>
                <p>因为没有明显地标识表明需要立即运行该函数所以浏览器会进行懒解析</p>
                <p>优化</p>
                <ul>
                    <li>
                        <p>首先，将函数存储在一个变量中</p>
                        <pre>
var foo = function foo(x) ｛
    return x * 10;
};
                        </pre>
                        <p>注意，这里有使用函数的名称 foo,这不是必需的，但是建议这样做，因为在抛出异常的情况下，stacktrace 会保留实际函数名称，而不仅仅是 anonymous</p>
                    </li>
                    <li>
                        <p>可以用括号封装起来，让解析器进行立即解析</p>
                        <pre>
var foo = (function foo(x) ｛
    return x * 10;
});
                        </pre>
                    </li>
                    <li>因为需要知道解析器在哪些情况下执行懒解析或者立即解析，所以很难手动管理</li>
                    <li>可以使用 Optimize.js 可以帮我们做这类事情，该工具只是用来优化 JavaScript
                        源代码的初始加载时间，它们对代码进行静态分析，然后通过使用括号封装需要立即运行的函数以便浏览器立即解析并准备运行它们</li>
                </ul>
            </li>
        </ul>
        <h6>预编译</h6>
        <p>从本质上讲，该思路是拥有可以生成字节码的务器端工具，这样只需要传输字节码并在客户端运行，之后会看到启动时间的一些主要差异</p>
        <h6>总结</h6>
        <ul>
            <li>检查依赖，减少不必要的依赖</li>
            <li>分割代码为更小的块而不是一整陀</li>
            <li>尽可能推迟加载 JavaScript，按需要加载或者动态加载</li>
            <li>使用开发者工具和 DeviceTiming 来检测性能瓶颈</li>
            <li>用像 Optimize.js 的工具来帮助解析器选择立即解析或者懒解析以加快解析速度</li>
            <li><a href="https://www.fundebug.com/">https://www.fundebug.com/</a></li>
        </ul>
    </ng-template>
</app-js-template-sum>
<app-js-template-sum title="视觉流组件构建">
    <ng-template appJsTemplateSum>
        <h6>组件分类</h6>
        <ul>
            <li>
                <p>原生组件</p>
                <span>系统本身自带的组件类型，例如按钮、导航、弹窗等等</span>
            </li>
            <li>
                <p>扩展组件</p>
                <span>基于原有组件基础，进行功能扩展，例如在导航栏上加下拉操作，在弹窗中加操作项等等</span>
            </li>
            <li>
                <p>自定义组件</p>
                <span>根据产品特点创造出来的特有组件</span>
            </li>
            <li>
                <p>封装组件</p>
                <span>对产品中经常出现的一系列场景页面进行组合封装的复杂组件</span>
            </li>
        </ul>
        <h6>颗粒化管理</h6>
        <ul>
            <li>
                <p>好处</p>
                <span>比较直观，没有复杂的组合逻辑、方便交接</span>
            </li>
            <li>
                <p>坏处</p>
                <span>难以管理、拓展性小，文件冗余、牵一发动全身</span>
            </li>
        </ul>
        <h6>组件的精细化管理</h6>
        <ul>
            <li>
                <p>结构细分</p>
                <ul>
                    <li>
                        <p>位置、尺寸的结构细分</p>
                        <span>一般模块拆解到按钮、图标等最细颗粒后通常不会再进行拆分，并且拆分模块不建议层级超过4个层级</span>
                    </li>
                    <li>
                        <p>颜色与字体样式</p>
                        <span>通过 Sketch 自带的 Layer Styles 和 Text Styles 进行管理，也可通过 Craft Manager 来管理</span>
                    </li>
                    <li>图标</li>
                    <li>图片与文案</li>
                </ul>
            </li>
            <li>
                <p>响应式布局</p>
            </li>
            <li>
                <p>命名</p>
                <ul>
                    <li>
                        <p>组件分类名</p>
                        <span>指组件的准确名称，如导航、工具栏、弹窗、按钮</span>
                    </li>
                    <li>
                        <p>组件的的细分模块命名</p>
                        <span>通过一些最容易理解的特征来区分</span>
                    </li>
                </ul>
            </li>
        </ul>
    </ng-template>
</app-js-template-sum>
<app-js-template-sum title="浏览器缓存机制">
    <ng-template appJsTemplateSum>
        <p>使用HTML Meta 标签，Web开发者可以在HTML页面的head节点中加入meta标签 CONTENT="no-cache"</p>
        <span>所有缓存代理服务器都不支持，因为代理不解析HTML内容本身</span>
        <h6>Expires策略(HTTP1.0 现在 HTTP1.1)</h6>
        <p>Expires是Web服务器响应消息头字段，在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求</p>
        <span>不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略</span>
        <h6>Cache-control策略</h6>
        <ul>
            <li>Cache-Control与Expires的作用一致，都是指明当前资源的有效期(控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据)</li>
            <li>Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires</li>
        </ul>
        <h6>Cache-control参数</h6>
        <p>值可以是public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age</p>
        <ul>
            <li>Public指示响应可被任何缓存区缓存</li>
            <li>Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效</li>
            <li>no-cache指示请求或响应消息不能缓存</li>
            <li>no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存</li>
            <li>max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应</li>
            <li>min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应</li>
            <li>max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息</li>
        </ul>
    </ng-template>
</app-js-template-sum>
<app-js-template-sum title="PNG 图片压缩原理解析">
    <ng-template appJsTemplateSum>
        <h6>PNG</h6>
        <p>PNG的全称叫便携式网络图型（Portable Network Graphics）是目前最流行的网络传输和展示的图片格式</p>
        <ul>
            <li>
                <p>无损压缩：PNG图片采取了基于LZ77派生算法对文件进行压缩，使得它压缩比率更高，生成的文件体积更小，并且不损失数据</p>
                <p>LZ77算法是由 Lempel-Ziv 在1977发明的，也是GBA内置的压缩算法</p>
            </li>
            <li>体积小：它利用特殊的编码方法标记重复出现的数据，使得同样格式的图片，PNG图片文件的体积更小</li>
            <li>支持透明效果：PNG支持对原图像定义256个透明层次，使得图像的边缘能与任何背景平滑融合，这种功能是GIF和JPEG没有的</li>
        </ul>
        <h6>PNG类型</h6>
        <p>PNG 8/ PNG 24 / PNG 32</p>
        <p>后面的数字代表拥有的颜色值</p>
        <ul>
            <li>8bits 2^8等于256 PNG8能存储256种颜色</li>
            <li>24bits 2^24等于16777216 R(0~255),G(0~255),B(0~255) PNG24能存储16777216种颜色</li>
            <li>32bits 2^32等于16777216 R(0~255),G(0~255),B(0~255),A(0~255) PNG32能存储很多颜色</li>
        </ul>
        <h6>PNG图片数据结构</h6>
        <ul>
            <li>header=>chunk...</li>
            <li>89504e470d0a1a0a：这个是PNG图片的头，所有的PNG图片的头都是这一串编码，图片软件通过这串编码判定这个文件是不是PNG格式的图片</li>
        </ul>
        <h6>PNG图片压缩</h6>
        <ul>
            <li>颜色越单一，颜色值越少，压缩率就越大</li>
            <li>
                <p>压缩过程</p>
                <ul>
                    <li>预解析（Prediction）：这个阶段就是对png图片进行一个预处理，处理后让它更方便后续的压缩</li>
                    <li>压缩（Compression）：执行Deflate压缩，该算法结合了 LZ77 算法和 Huffman 算法对图片进行编码</li>
                </ul>
            </li>
        </ul>
    </ng-template>
</app-js-template-sum>
<app-js-template-sum title="异步编程 6种">
    <ng-template appJsTemplateSum>
        <h6>总结</h6>
        <ul>
            <li>
                <p>回调函数</p>
                <pre>{{jsAsyncSumUp.callBack}}</pre>
            </li>
            <li>
                <p>事件监听</p>
                <pre>{{jsAsyncSumUp.eventWatch}}</pre>
            </li>
            <li>
                <p>发布订阅</p>
                <pre>{{jsAsyncSumUp.subscribe}}</pre>
            </li>
            <li>
                <p>Promise</p>
                <pre>{{jsAsyncSumUp.promise}}</pre>
            </li>
            <li>
                <p>Generator</p>
                <ul>
                    <li>Generator 函数是一个状态机，封装了多个内部状态</li>
                    <li>执行 Generator 函数会返回一个遍历器对象，使用该对象的 next() 方法，可以遍历 Generator 函数内部的每一个状态，直到 return 语句</li>
                    <li>1.function关键字与函数名之间有一个星号</li>
                    <li>2.函数体内部使用yield表达式， yield是暂停执行的标记</li>
                    <li>next() 方法遇到yield表达式，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值</li>
                </ul>
                <pre>{{jsAsyncSumUp.generator}}</pre>
            </li>
            <li>
                <p>async</p>
                <ul>
                    <li>async函数返回的是一个 Promise 对象</li>
                    <li>可以使用 then 方法添加回调函数，async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数</li>
                    <li>当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句</li>
                </ul>
                <pre>{{jsAsyncSumUp.async}}</pre>
            </li>
        </ul>
    </ng-template>
</app-js-template-sum>
<app-js-template-sum title="JavaScript 复杂判断的更优雅写法">
    <ng-template appJsTemplateSum>
        <ul>
            <li>if/else</li>
            <li>switch</li>
            <li>一元判断时：存到Object里</li>
            <li>一元判断时：存到Map里</li>
            <li>多元判断时：将condition拼接成字符串存到Object里</li>
            <li>多元判断时：将condition拼接成字符串存到Map里</li>
            <li>多元判断时：将condition存为Object存到Map里</li>
            <li>多元判断时：将condition写作正则存到Map里</li>
        </ul>
        <pre>{{complexJudgment}}</pre>
    </ng-template>
</app-js-template-sum>
<app-js-template-sum title="JavaScript 异步 总结">
    <ng-template appJsTemplateSum>
        <h6>浏览器线程</h6>
        <p>GUI 与 js 线程互斥</p>
        <ul>
            <li>GUI渲染线程 - GUI渲染线程处于挂起状态的，也就是冻结状态</li>
            <li>JavaScript引擎线程 - 用于解析JavaScript代码</li>
            <li>定时器触发线程 - 浏览器定时计数器并不是 js引擎计数</li>
            <li>浏览器事件线程 - 用于解析BOM渲染等工作</li>
            <li>http线程 - 主要负责数据请求</li>
            <li>EventLoop轮询处理线程 - 事件被触发时该线程会把事件添加到待处理队列的队尾</li>
            <li>
                <p>进程</p>
                <p>进程是指在操作系统中正在运行的一个应用程序</p>
            </li>
            <li>
                <p>线程</p>
                <ul>
                    <li>线程是指进程内独立执行某个任务的一个单元</li>
                    <li>线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源(如程序计数器，一组寄存器和栈)</li>
                </ul>
            </li>
            <li>
                <p>进程 && 线程</p>
                <ul>
                    <li>进程中包含线程，一个进程中可以有N个进程</li>
                    <li>比如打开3个浏览器，那么就开启了3个进程</li>
                </ul>
            </li>
        </ul>
        <h6>异步运行机制</h6>
        <ul>
            <li>所有同步任务都在主线程上执行，形成一个执行栈</li>
            <li>
                <p>主线程之外，还存在一个 任务队列</p>
                <p>只要异步任务有了运行结果，就在 任务队列之中放置一个事件</p>
            </li>
            <li>
                <p>一旦 执行栈中的所有同步任务执行完毕，系统就会读取 任务队列，看看里面有哪些事件</p>
                <p>那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行</p>
            </li>                    
            <li>
                主线程不断重复上面的第三步
            </li>
        </ul>
        <pre>{{jsAsyncSumUp.asyncDemo}}</pre>
        <ul>
            <li>updateSync函数运行过程中 UI更新被阻塞，只有当它结束退出后才会更新 UI</li>
            <li>当点击 异步的时候，会明显的看到 Dom在逐步更新的过程</li>
        </ul>
        <p>回调函数应用场景</p>
        <ul>
            <li>资源加载：动态加载js文件后执行回调，加载iframe后执行回调，ajax操作回调，图片加载完成执行回调，AJAX</li>
            <li>DOM事件及Node.js事件基于回调机制(Node.js回调可能会出现多层回调嵌套的问题)</li>
            <li>setTimeout的延迟时间为0，这个hack经常被用到，settimeout调用的函数其实就是一个callback的体现</li>
            <li>链式调用：链式调用的时候，在赋值器(setter)方法中(或者本身没有返回值的方法中)很容易实现链式调用，而取值器(getter)相对来说不好实现链式调用，因为你需要取值器返回你需要的数据而不是this指针，如果要实现链式方法，可以用回调函数来实现</li>
            <li>setTimeout、setInterval的函数调用得到其返回值</li>
        </ul>
        <p>https://mp.weixin.qq.com/s/Ek5ONtorGbDtgvcPkivVVA</p>
    </ng-template>
</app-js-template-sum>