<nz-card class="mar-b-20" nzTitle="window.performance.timing" [ngClass]="{'switchHide': !timing}" [nzExtra]="timingTemplate">
    <div *ngIf="timing">
        <h3>window.performance.timing(html5的属性)</h3>
        <ul>
            <li>
                <h6>navigationStart</h6>
                <p>当前浏览器窗口的前一个网页关闭，发生unload事件时的Unix毫秒时间戳。如果没有前一个网页，则等于fetchStart属性</p>
            </li>
            <li>
                <h6>unloadEventStart</h6>
                <p>如果前一个网页与当前网页属于同一个域名，则返回前一个网页的unload事件发生时的Unix毫秒时间戳。如果没有前一个网页，或者之前的网页跳转不是在同一个域名内，则返回值为0</p>
            </li>
            <li>
                <h6>unloadEventEnd</h6>
                <p>如果前一个网页与当前网页属于同一个域名，则返回前一个网页unload事件的回调函数结束时的Unix毫秒时间戳。如果没有前一个网页，或者之前的网页跳转不是在同一个域名内，则返回值为0</p>
            </li>
            <li>
                <h6>redirectStart</h6>
                <p>返回第一个HTTP跳转开始时的Unix毫秒时间戳。如果没有跳转，或者不是同一个域名内部的跳转，则返回值为0</p>
            </li>
            <li>
                <h6>redirectEnd</h6>
                <p>返回最后一个HTTP跳转结束时（即跳转回应的最后一个字节接受完成时）的Unix毫秒时间戳。如果没有跳转，或者不是同一个域名内部的跳转，则返回值为0</p>
            </li>
            <li>
                <h6>fetchStart</h6>
                <p>返回浏览器准备使用HTTP请求读取文档时的Unix毫秒时间戳。该事件在网页查询本地缓存之前发生</p>
            </li>
            <li>
                <h6>domainLookupStart</h6>
                <p>返回域名查询开始时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值</p>
            </li>
            <li>
                <h6>domainLookupEnd</h6>
                <p>返回域名查询结束时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值</p>
            </li>
            <li>
                <h6>connectStart</h6>
                <p>返回HTTP请求开始向服务器发送时的Unix毫秒时间戳。如果使用持久连接（persistent connection），则返回值等同于fetchStart属性的值</p>
            </li>
            <li>
                <h6>connectEnd</h6>
                <p>返回浏览器与服务器之间的连接建立时的Unix毫秒时间戳。如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束</p>
            </li>
            <li>
                <h6>secureConnectionStart</h6>
                <p>返回浏览器与服务器开始安全链接的握手时的Unix毫秒时间戳。如果当前网页不要求安全连接，则返回0</p>
            </li>
            <li>
                <h6>requestStart</h6>
                <p>返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的Unix毫秒时间戳</p>
            </li>
            <li>
                <h6>responseStart</h6>
                <p>返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的Unix毫秒时间戳</p>
            </li>
            <li>
                <h6>responseEnd</h6>
                <p>返回浏览器从服务器收到（或从本地缓存读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的Unix毫秒时间戳</p>
            </li>
            <li>
                <h6>domLoading</h6>
                <p>返回当前网页DOM结构开始解析时（即Document.readyState属性变为“loading”、相应的readystatechange事件触发时）的Unix毫秒时间戳</p>
            </li>
            <li>
                <h6>domInteractive</h6>
                <p>返回当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为“interactive”、相应的readystatechange事件触发时）的Unix毫秒时间戳</p>
            </li>
            <li>
                <h6>domContentLoadedEventStart</h6>
                <p>返回当前网页DOMContentLoaded事件发生时（即DOM结构解析完毕、所有脚本开始运行时）的Unix毫秒时间戳</p>
            </li>
            <li>
                <h6>domContentLoadedEventEnd</h6>
                <p>返回当前网页所有需要执行的脚本执行完成时的Unix毫秒时间戳</p>
            </li>
            <li>
                <h6>domComplete</h6>
                <p>返回当前网页DOM结构生成时（即Document.readyState属性变为“complete”，以及相应的readystatechange事件发生时）的Unix毫秒时间戳</p>
            </li>
            <li>
                <h6>loadEventStart</h6>
                <p>返回当前网页load事件的回调函数开始时的Unix毫秒时间戳。如果该事件还没有发生，返回0</p>
            </li>
            <li>
                <h6>loadEventEnd</h6>
                <p>返回当前网页load事件的回调函数运行结束时的Unix毫秒时间戳。如果该事件还没有发生，返回0</p>
            </li>
        </ul>
    </div>
</nz-card>
<ng-template #timingTemplate>
    <a (click)="switch('timing')">{{timing? '关闭': '打开'}}</a>
</ng-template>
<nz-card class="mar-b-20" nzTitle="了解html页面的渲染过程" [ngClass]="{'switchHide': !rendering}" [nzExtra]="renderingTemplate">
    <div *ngIf="rendering">
        <h3>页面的渲染</h3>
        <ul>
            <li>单线程事件轮询</li>
            <li>定义明确、连续、操作有序（HTML5）</li>
            <li>分词和构建DOM树</li>
            <li>请求资源并预加载</li>
            <li>构建渲染树并绘制页面</li>
        </ul>
        <h6>DOM树的构建会被阻塞</h6>
        <ul>
            <li>HTML的响应流被阻塞在了网络中</li>
            <li>有未加载完的脚本</li>
            <li>遇到了script节点，但是此时还有未加载完的样式文件</li>
        </ul>
        <h6>不会阻塞页面渲染</h6>
        <ul>
            <li>定义的defer属性和async属性</li>
            <li>没有匹配的媒体类型的样式文件</li>
            <li>没有通过解析器插入script节点或样式节点</li>
        </ul>
    </div>
</nz-card>
<ng-template #renderingTemplate>
    <a (click)="switch('rendering')">{{rendering? '关闭': '打开'}}</a>
</ng-template>
<nz-card class="mar-b-20" nzTitle="渲染树构建之渲染树和DOM树的关系" [ngClass]="{'switchHide': !renderTree}" [nzExtra]="renderTreeTemplate">
    <div *ngIf="renderTree">
        <h3>渲染树构建之渲染树和DOM树的关系</h3>
        <ul>
            <li>在DOM树构建的同时，浏览器会构建渲染树（render tree）</li>
            <li>渲染树的节点（渲染器），在Gecko中称为frame，而在webkit中称为renderer</li>
            <li>渲染器是在文档解析和创建DOM节点后创建的，会计算DOM节点的样式信息</li>
            <li> 在webkit中，renderer是由DOM节点调用attach()方法创建的</li>
            <li>
                <p>attach()方法计算了DOM节点的样式信息</p>
                <ul>
                    <li>attach()是自上而下的递归操作。也就是说，父节点总是比子节点先创建自己的renderer</li>
                    <li>销毁的时候，则是自下而上的递归操作，也就是说，子节点总是比父节点先销毁</li>
                </ul>
            </li>
        </ul>
    </div>
</nz-card>
<ng-template #renderTreeTemplate>
    <a (click)="switch('renderTree')">{{renderTree? '关闭': '打开'}}</a>
</ng-template>
<nz-card class="mar-b-20" nzTitle="浏览器的运行机制" [ngClass]="{'switchHide': !operatingMechanism}" [nzExtra]="operatingMechanismTemplate">
    <div *ngIf="operatingMechanism">
        <h3>渲染进程包括哪些线程</h3>
        <ul>
            <li>
                <h6>GUI渲染线程</h6>
                <ul>
                    <li>负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等</li>
                    <li>当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行</li>
                    <li>注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行</li>
                </ul>
            </li>
            <li>
                <h6>JS引擎线程(单线程)</h6>
                <ul>
                    <li>也称为JS内核，负责处理Javascript脚本程序。（例如常常听到的谷歌浏览器的V8引擎，新版火狐的JaegerMonkey引擎等）</li>
                    <li>JS引擎线程负责解析Javascript脚本，运行代码</li>
                    <li>JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</li>
                    <li>同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞</li>
                </ul>
            </li>
            <li>
                <h6>事件触发线程</h6>
                <ul>
                    <li>归属于渲染进程而不是JS引擎，用来控制事件轮询（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）</li>
                    <li>当JS引擎执行代码块如鼠标点击、AJAX异步请求等，会将对应任务添加到事件触发线程中</li>
                    <li>当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理任务队列的队尾，等待JS引擎的处理</li>
                    <li>注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）</li>
                </ul>
            </li>
            <li>
                <h6>定时触发器线程</h6>
                <ul>
                    <li>定时器setInterval与setTimeout所在线程</li>
                    <li>浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果任务队列处于阻塞线程状态就会影响记计时的准确）</li>
                    <li>因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）</li>
                    <li>注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms</li>
                </ul>
            </li>
            <li>
                <h6>异步http请求线程</h6>
                <ul>
                    <li>用于处理请求XMLHttpRequest，在连接后是通过浏览器新开一个线程请求。如ajax，是浏览器新开一个http线程</li>
                    <li>将检测到状态变更（如ajax返回结果）时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入js引擎线程的事件队列中。再由JavaScript引擎执行</li>
                </ul>
            </li>
            <li>
                <h6>渲染进程中的线程之间的关系</h6>
                <ul>
                    <li>
                        <p>GUI渲染线程与JS引擎线程互斥</p>
                        <ul>
                            <li>由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和GUI线程同时运行）</li>
                            <li>那么渲染线程前后获得的元素数据就可能不一致了</li>
                            <li>浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起</li>
                            <li>GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行</li>
                        </ul>
                    </li>
                    <li>
                        <p>JS阻塞页面加载</p>
                        <ul>
                            <li>JS如果执行时间过长就会阻塞页面</li>
                            <li>所以JS引擎很可能很久很久后才能空闲，所以导致页面渲染加载阻塞</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <h6>js引擎是单线程的</h6>
                <ul>
                    <li>作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM</li>
                    <li>JavaScript就是单线程，这已经成了这门语言的核心特征，将来也不会改变</li>
                    <li>
                        <p>HTML5提出Web Worker标准</p>
                        <ul>
                            <li>允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM</li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <h6>js事件轮询</h6>
                <ul>
                    <li>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着</li>
                    <li>如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行</li>
                    <li>
                        <p>io设备的限制</p>
                        <ul>
                            <li>
                                <p>一种是同步任务（synchronous）</p>
                                <ul>
                                    <li>在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务</li>
                                </ul>
                            </li>
                            <li>
                                <p>一种是异步任务（asynchronous）</p>
                                <ul>
                                    <li>异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <p>js的事件轮询机制</p>
                        <ul>
                            <li>所有同步任务都在主线程（即js引擎线程）上执行，形成一个执行栈</li>
                            <li>
                                <p>异步任务均由事件触发线程控制，其有一个任务队列</p>
                                <ul>
                                    <li>只要异步任务有了运行结果，就在"任务队列"之中放置回调事件</li>
                                    <li>异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数</li>
                                    <li>所以所谓"回调函数"（callback），就是那些会被主线程挂起来的代码</li>
                                </ul>
                            </li>
                            <li>一旦"执行栈"中的所有同步任务执行完毕，系统就会读取"任务队列"，按顺序结束等待状态，进入执行栈，开始执行</li>
                            <li>主线程不断重复上面的第三步</li>
                            <li>
                                <p>同步异步执行顺序</p>
                                <ul>
                                    <li>只要主线程空了，就会去读取"任务队列"，这个过程会不断重复</li>
                                    <li>这就是JavaScript的运行机制。又称为Event Loop（事件循环或者轮询）</li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li>
                <h6>定时器触发线程</h6>
                <p>JS引擎线程和事件触发线程</p>
                <ul>
                    <li>js来控制主线程，事件触发来控制任务队列就如主线程</li>
                    <li>JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确，因此很有必要单独开一个线程用来计时</li>
                    <li>当使用setTimeout或setInterval时，它需要定时器线程计时，计时完成后就会将特定的事件推入事件触发线程的任务队列中</li>
                </ul>
            </li>
            <li>
                <h6>注意</h6>
                <ul>
                    <li>虽然代码的本意是0毫秒后就推入事件队列，但是html5标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms</li>
                    <li>算不等待4ms，就算假设0毫秒就推入事件队列，也会先执行begin（因为只有主线程可执行栈内空了后才会主动读取事件队列）</li>
                    <li>
                        <p>误差</p>
                        <ul>
                            <li>回调函数一定会在setTimeout()指定的时间执行。同理setInterval则是每次都精确的隔一段时间推入一个事件</li>
                            <li>事件的实际执行时间不一定就准确，还有可能是这个事件还没执行完毕，下一个事件就来了</li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
    </div>
</nz-card>
<ng-template #operatingMechanismTemplate>
    <a (click)="switch('operatingMechanism')">{{operatingMechanism? '关闭': '打开'}}</a>
</ng-template>
<nz-card class="mar-b-20" nzTitle="JS事件循环机制（event loop）之宏任务、微任务" [ngClass]="{'switchHide': !eventLoop}" [nzExtra]="eventLoopTemplate">
    <ul *ngIf="eventLoop">
        <li>
            <pre>
                console.log('script start');

                setTimeout(function() ｛
                    console.log('setTimeout');
                ｝, 0);

                Promise.resolve().then(function() ｛
                        console.log('promise1');
                    ｝).then(function() ｛
                        console.log('promise2');
                ｝);

                console.log('script end');
            </pre>
            <p></p>
        </li>
    </ul>
</nz-card>
<ng-template #eventLoopTemplate>
    <a (click)="switch('eventLoop')">{{eventLoop? '关闭': '打开'}}</a>
</ng-template>